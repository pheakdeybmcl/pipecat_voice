<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Call Center Console</title>
  <style>
    :root {
      --bg: #eef1f7;
      --bg-2: #f9fafc;
      --phone: #ffffff;
      --ink: #1e2430;
      --muted: #7a8394;
      --line: #e3e6ee;
      --soft: #f1f3f8;
      --accent: #0f1722;
      --accent-2: #3a475b;
      --green: #28b07a;
      --red: #ef4b4b;
      --shadow: 0 18px 40px rgba(33, 45, 65, 0.15);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Sora", "Space Grotesk", "Trebuchet MS", sans-serif;
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(40, 176, 122, 0.16), transparent 60%),
        radial-gradient(900px 600px at 85% 0%, rgba(75, 140, 255, 0.12), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg-2));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 22px;
      color: var(--ink);
    }
    .layout {
      width: min(1180px, 96vw);
      display: grid;
      grid-template-columns: minmax(320px, 420px) minmax(320px, 1fr);
      gap: 26px;
      align-items: start;
      justify-content: center;
    }
    .layout.single {
      grid-template-columns: 1fr;
      justify-items: center;
    }
    .layout.single .side-panel {
      display: none;
    }
    .phone-shell {
      width: min(420px, 95vw);
      background: var(--phone);
      border-radius: 34px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 22px 18px 26px;
      position: relative;
      overflow: hidden;
    }
    .side-panel {
      background: var(--phone);
      border-radius: 30px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 22px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .side-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--muted);
    }
    .phone-shell::before {
      content: "";
      position: absolute;
      inset: -40% auto auto -30%;
      width: 240px;
      height: 240px;
      background: radial-gradient(circle, rgba(40, 176, 122, 0.12), transparent 60%);
      pointer-events: none;
    }
    .screen { display: flex; flex-direction: column; align-items: center; gap: 18px; }
    .hidden { display: none; }
    .idle-card {
      width: 100%;
      padding: 22px 18px 30px;
      border-radius: 26px;
      background: linear-gradient(180deg, #ffffff, #f6f7fb);
      border: 1px solid var(--line);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
    }
    .avatar {
      width: 76px;
      height: 76px;
      border-radius: 50%;
      background: linear-gradient(140deg, #e2e7f1, #f8fbff);
      display: grid;
      place-items: center;
      font-weight: 700;
      color: var(--accent-2);
      font-size: 22px;
      letter-spacing: 1px;
    }
    .idle-title { font-size: 20px; font-weight: 700; }
    .idle-sub { font-size: 13px; color: var(--muted); }
    .call-btn {
      width: 160px;
      border: none;
      border-radius: 999px;
      padding: 12px 18px;
      background: linear-gradient(135deg, #0f1722, #2f3b4f);
      color: #fff;
      font-weight: 600;
      letter-spacing: 0.4px;
      cursor: pointer;
      box-shadow: 0 12px 26px rgba(15, 23, 34, 0.2);
    }
    .call-header {
      width: 100%;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .call-name { font-size: 20px; font-weight: 700; letter-spacing: 0.4px; }
    .call-meta {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      color: var(--muted);
      font-size: 13px;
    }
    .talk-state {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--muted);
    }
    .state-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #c7cfdd;
    }
    .state-dot.listening { background: #2fbf7b; box-shadow: 0 0 6px rgba(47, 191, 123, 0.5); }
    .state-dot.processing { background: #f0b44c; box-shadow: 0 0 6px rgba(240, 180, 76, 0.45); }
    .state-dot.speaking { background: #4b8cff; box-shadow: 0 0 6px rgba(75, 140, 255, 0.5); }
    .state-dot.muted { background: #a6afbf; }
    #status {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #f5f6fb;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.6px;
    }
    #status[data-state="CONNECTED"] { background: rgba(40, 176, 122, 0.15); color: #0f6a47; }
    #status[data-state="CONNECTING"] { background: rgba(75, 140, 255, 0.16); color: #2b4d90; }
    #status[data-state="DISCONNECTED"] { background: rgba(239, 75, 75, 0.12); color: #9a2d2d; }
    #callTimer { font-weight: 600; color: var(--accent-2); }
    .rec-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #d12c2c;
      opacity: 0;
      transition: opacity 150ms ease;
    }
    .rec-indicator::before {
      content: "";
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #ef4b4b;
      box-shadow: 0 0 8px rgba(239, 75, 75, 0.6);
    }
    .rec-indicator.active { opacity: 1; }
    .sound-icon { display: flex; justify-content: center; }
    .sound-icon.disabled .bar { animation-play-state: paused; height: 6px; opacity: .35; }
    .sound-wave { width: 220px; height: 60px; display: flex; justify-content: space-around; align-items: center; }
    .sound-wave .bar {
      display: block;
      width: 3px;
      margin-right: 1px;
      height: 52px;
      background: #2f3b4f;
      animation: sound 0ms -800ms linear infinite alternate;
      transition: height 0.8s;
      border-radius: 6px;
    }
    @keyframes sound {
      0% { opacity: .35; height: 6px; }
      100% { opacity: 1; height: 38px; }
    }
    .sound-wave .bar:nth-child(1)  { height: 2px; animation-duration: 474ms; }
    .sound-wave .bar:nth-child(2)  { height: 10px; animation-duration: 433ms; }
    .sound-wave .bar:nth-child(3)  { height: 18px; animation-duration: 407ms; }
    .sound-wave .bar:nth-child(4)  { height: 26px; animation-duration: 458ms; }
    .sound-wave .bar:nth-child(5)  { height: 30px; animation-duration: 400ms; }
    .sound-wave .bar:nth-child(6)  { height: 32px; animation-duration: 427ms; }
    .sound-wave .bar:nth-child(7)  { height: 34px; animation-duration: 441ms; }
    .sound-wave .bar:nth-child(8)  { height: 36px; animation-duration: 419ms; }
    .sound-wave .bar:nth-child(9)  { height: 40px; animation-duration: 487ms; }
    .sound-wave .bar:nth-child(10) { height: 46px; animation-duration: 442ms; }
    .sound-wave .bar:nth-child(11) { height: 2px; animation-duration: 474ms; }
    .sound-wave .bar:nth-child(12) { height: 10px; animation-duration: 433ms; }
    .sound-wave .bar:nth-child(13) { height: 18px; animation-duration: 407ms; }
    .sound-wave .bar:nth-child(14) { height: 26px; animation-duration: 458ms; }
    .sound-wave .bar:nth-child(15) { height: 30px; animation-duration: 400ms; }
    .sound-wave .bar:nth-child(16) { height: 32px; animation-duration: 427ms; }
    .sound-wave .bar:nth-child(17) { height: 34px; animation-duration: 441ms; }
    .sound-wave .bar:nth-child(18) { height: 36px; animation-duration: 419ms; }
    .sound-wave .bar:nth-child(19) { height: 40px; animation-duration: 487ms; }
    .sound-wave .bar:nth-child(20) { height: 46px; animation-duration: 442ms; }
    .unlock {
      border: none;
      border-radius: 999px;
      padding: 6px 14px;
      background: #0f1722;
      color: #fff;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(15, 23, 34, 0.18);
    }
    .action-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 14px;
      width: 100%;
      justify-items: center;
      margin-top: 4px;
    }
    .action-btn {
      width: 86px;
      height: 86px;
      border-radius: 26px;
      border: 1px solid var(--line);
      background: var(--soft);
      color: var(--accent-2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 11px;
      letter-spacing: 0.4px;
      cursor: pointer;
      transition: transform 120ms ease, background 180ms ease, border-color 180ms ease;
    }
    .action-btn:hover:not(:disabled) { transform: translateY(-1px); }
    .action-btn:disabled { opacity: 0.45; cursor: not-allowed; }
    .action-btn.active {
      background: #101826;
      color: #fff;
      border-color: #101826;
      box-shadow: 0 10px 20px rgba(16, 24, 38, 0.2);
    }
    .action-icon { width: 22px; height: 22px; }
    .action-label { font-size: 11px; }
    .hangup-btn {
      margin-top: 16px;
      width: 86px;
      height: 86px;
      border-radius: 50%;
      border: none;
      background: var(--red);
      color: #fff;
      font-weight: 700;
      letter-spacing: 0.6px;
      cursor: pointer;
      box-shadow: 0 16px 26px rgba(239, 75, 75, 0.25);
    }
    .chat-panel, .advanced-panel {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .bubble {
      border-radius: 16px;
      padding: 12px 14px;
      background: #f6f7fb;
      border: 1px solid var(--line);
      min-height: 64px;
    }
    .bubble.agent { background: #eef2fb; }
    .bubble .label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.4px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .input-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    input[type="text"], select {
      width: 100%;
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink);
      outline: none;
    }
    button.send-btn {
      border: none;
      border-radius: 14px;
      padding: 10px 16px;
      background: #0f1722;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    button.send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    label, .field-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--muted);
    }
    input[type="range"] { width: 100%; accent-color: #1b2b3f; }
    #log {
      white-space: pre-wrap;
      background: #0f1722;
      color: #dbe3ef;
      padding: 12px;
      border-radius: 12px;
      height: 180px;
      overflow: auto;
      font-family: "JetBrains Mono", "IBM Plex Mono", ui-monospace, monospace;
    }
    .recordings {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .recordings a {
      font-size: 12px;
      color: #2b4d90;
      text-decoration: none;
    }
    @media (max-width: 420px) {
      .action-btn { width: 76px; height: 76px; }
      .hangup-btn { width: 76px; height: 76px; }
    }
    @media (max-width: 980px) {
      .layout {
        grid-template-columns: 1fr;
        justify-items: center;
      }
      .side-panel {
        width: min(620px, 95vw);
      }
    }
  </style>
</head>
<body>
  <div class="layout single">
    <div class="phone-shell">
      <section id="screenIdle" class="screen">
        <div class="idle-card">
          <div class="avatar">Echo</div>
          <div class="idle-title">Call Echo</div>
          <div class="idle-sub">Tap to start a live session</div>
          <button id="btnCall" class="call-btn">Call Echo</button>
        </div>
      </section>

      <section id="screenCall" class="screen hidden">
        <div class="call-header">
          <div class="call-name">Echo</div>
        <div class="call-meta">
          <span id="status" data-state="DISCONNECTED">DISCONNECTED</span>
          <span id="callTimer">00:00</span>
          <span class="talk-state"><span id="talkStateDot" class="state-dot muted"></span><span id="talkStateLabel">Muted</span></span>
          <span id="recIndicator" class="rec-indicator">REC</span>
        </div>
      </div>

        <div id="soundIcon" class="sound-icon disabled" aria-label="AI speaking indicator">
          <div class="sound-wave">
            <span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span>
            <span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span>
            <span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span>
            <span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span><span class="bar"></span>
          </div>
        </div>
        <button id="audioUnlock" class="unlock hidden" type="button">Tap to Enable Audio</button>

        <div class="action-grid">
          <button id="btnMute" class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="9" y="3" width="6" height="10" rx="3"></rect>
              <path d="M5 11a7 7 0 0 0 14 0"></path>
              <path d="M12 18v3"></path>
            </svg>
            <span class="action-label" id="labelMute">Mute</span>
          </button>
          <button id="btnKeypad" class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
              <circle cx="7" cy="7" r="2"></circle>
              <circle cx="12" cy="7" r="2"></circle>
              <circle cx="17" cy="7" r="2"></circle>
              <circle cx="7" cy="12" r="2"></circle>
              <circle cx="12" cy="12" r="2"></circle>
              <circle cx="17" cy="12" r="2"></circle>
              <circle cx="7" cy="17" r="2"></circle>
              <circle cx="12" cy="17" r="2"></circle>
              <circle cx="17" cy="17" r="2"></circle>
            </svg>
            <span class="action-label" id="labelKeypad">Keypad</span>
          </button>
          <button id="btnAudio" class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 9h4l6-5v16l-6-5H4z"></path>
              <path d="M18 9a3 3 0 0 1 0 6"></path>
              <path d="M20 7a6 6 0 0 1 0 10"></path>
            </svg>
            <span class="action-label" id="labelAudio">Audio</span>
          </button>
          <button class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 5v14"></path>
              <path d="M5 12h14"></path>
            </svg>
            <span class="action-label">Add Call</span>
          </button>
          <button id="btnHold" class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
              <rect x="6" y="5" width="4" height="14" rx="2"></rect>
              <rect x="14" y="5" width="4" height="14" rx="2"></rect>
            </svg>
            <span class="action-label">Hold</span>
          </button>
          <button class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M7 7h10v6"></path>
              <path d="M17 7l-3-3"></path>
              <path d="M7 17h10v-6"></path>
              <path d="M7 17l3 3"></path>
            </svg>
            <span class="action-label">Transfer</span>
          </button>
          <button id="btnRecord" class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
              <circle cx="12" cy="12" r="6"></circle>
            </svg>
            <span class="action-label" id="labelRecord">Record</span>
          </button>
          <button class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="7" width="12" height="10" rx="2"></rect>
              <path d="M17 9l4-2v10l-4-2z"></path>
            </svg>
            <span class="action-label">Meet</span>
          </button>
          <button id="btnMore" class="action-btn" disabled>
            <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
              <circle cx="6" cy="12" r="2"></circle>
              <circle cx="12" cy="12" r="2"></circle>
              <circle cx="18" cy="12" r="2"></circle>
            </svg>
            <span class="action-label">More</span>
          </button>
        </div>

        <button id="btnHangup" class="hangup-btn" disabled>
          <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12c2-3 6-4 9-4s7 1 9 4"></path>
            <path d="M6 15l-2 4"></path>
            <path d="M18 15l2 4"></path>
          </svg>
        </button>
      </section>
    </div>

    <aside class="side-panel">
      <div class="side-title">Conversation</div>
      <div id="chatPanel" class="chat-panel">
        <div class="bubble">
          <div class="label">Caller</div>
          <div id="transcript"></div>
        </div>
        <div class="bubble agent">
          <div class="label">Agent</div>
          <div id="aiText"></div>
        </div>
        <div class="input-row">
          <input id="textInput" type="text" placeholder="Type a message and send" />
          <button id="btnSend" class="send-btn" disabled>Send</button>
        </div>
      </div>

      <div class="side-title">Settings</div>
      <div id="advancedPanel" class="advanced-panel">
        <div class="field">
          <label for="wsUrl">WS Url</label>
          <input id="wsUrl" type="text" value="" />
        </div>
        <div class="field">
          <label for="serverVoiceSelect">Server Voice</label>
          <div class="input-row">
            <select id="serverVoiceSelect"></select>
            <button id="btnRefreshVoices" class="send-btn" disabled>Refresh</button>
          </div>
        </div>
        <div class="field">
          <label for="rate">Rate</label>
          <div class="input-row">
            <input id="rate" type="range" min="0.7" max="1.3" step="0.05" value="1.0" />
            <span id="rateVal">1.0</span>
          </div>
        </div>
        <div class="field">
          <div class="field-title">Recordings</div>
          <div id="recordings" class="recordings"></div>
        </div>
        <div class="field">
          <div class="field-title">Event Log</div>
          <div id="log"></div>
        </div>
      </div>
    </aside>
  </div>

<script>
(() => {
  // UI
  const screenIdle = document.getElementById("screenIdle");
  const screenCall = document.getElementById("screenCall");
  const layoutEl = document.querySelector(".layout");
  const chatPanel = document.getElementById("chatPanel");
  const advancedPanel = document.getElementById("advancedPanel");

  const logEl = document.getElementById("log");
  const transcriptEl = document.getElementById("transcript");
  const aiTextEl = document.getElementById("aiText");
  const statusEl = document.getElementById("status");
  const callTimerEl = document.getElementById("callTimer");
  const recIndicatorEl = document.getElementById("recIndicator");
  const recordingsEl = document.getElementById("recordings");
  const talkStateDotEl = document.getElementById("talkStateDot");
  const talkStateLabelEl = document.getElementById("talkStateLabel");

  const btnCall = document.getElementById("btnCall");
  const btnHangup = document.getElementById("btnHangup");
  const btnMute = document.getElementById("btnMute");
  const btnKeypad = document.getElementById("btnKeypad");
  const btnAudio = document.getElementById("btnAudio");
  const btnHold = document.getElementById("btnHold");
  const btnRecord = document.getElementById("btnRecord");
  const btnMore = document.getElementById("btnMore");

  const labelMute = document.getElementById("labelMute");
  const labelAudio = document.getElementById("labelAudio");
  const labelRecord = document.getElementById("labelRecord");
  const labelKeypad = document.getElementById("labelKeypad");

  const wsUrlEl = document.getElementById("wsUrl");
  const textInputEl = document.getElementById("textInput");
  const btnSend = document.getElementById("btnSend");
  const soundIconEl = document.getElementById("soundIcon");
  const audioUnlockEl = document.getElementById("audioUnlock");

  const voiceSelect = document.getElementById("voiceSelect");
  const rateEl = document.getElementById("rate");
  const rateVal = document.getElementById("rateVal");
  const serverVoiceSelect = document.getElementById("serverVoiceSelect");
  const btnRefreshVoices = document.getElementById("btnRefreshVoices");

  // WS
  let ws = null;
  let connected = false;
  let serverTtsEnabled = false;
  let serverVoice = "";
  let callTimerId = null;
  let callStartMs = 0;
  let audioOutputMuted = false;
  let callInitiated = false;

  // Audio capture / mix
  let mixCtx = null;
  let mixDest = null;
  let aiSource = null;
  let micStream = null;
  let sourceNode = null;
  let processor = null;
  let micRunning = false;

  // Browser TTS + server audio
  let voices = [];
  let ttsChunks = [];
  let ttsFallbackTimer = null;
  let ttsChunkFallbackTimer = null;
  let ttsFallbackText = "";
  let audioStartSeen = false;
  let audioChunkSeen = false;
  let pendingConnect = false;
  const REQUIRE_AUDIO_UNLOCK = true;
  let recording = false;
  let recordRecorder = null;
  let recordChunks = [];
  let audioUnlocked = false;
  let audioUnlocking = false;
  let aiSpeaking = false;
  let pendingAiText = "";
  let aiProcessing = false;
  let pendingAudioBlob = null;
  let pendingAudioUrl = "";
  let speakingGuardId = null;
  let turnState = "idle";
  let autoListenEnabled = false;
  const pushToTalkEnabled = true;
  let pushToTalkActive = false;
  let pushToTalkStopTimer = null;
  const PUSH_TO_TALK_RELEASE_MS = 300;
  const allowBargeIn = false;
  const blockMicWhileAiSpeaking = true;
  const SILENT_WAV = "data:audio/wav;base64,UklGRjQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YRAAAAAAAAAAAAAAAAAAAAAAAAAA";

  if (wsUrlEl && !wsUrlEl.value) {
    const proto = window.location.protocol === "https:" ? "wss" : "ws";
    const host = window.location.host || "localhost:8000";
    wsUrlEl.value = `${proto}://${host}/ws`;
  }

  function getOrCreateSessionId() {
    const key = "voice_session_id";
    const existing = localStorage.getItem(key);
    if (existing) return existing;
    let id = "";
    if (window.crypto && typeof window.crypto.randomUUID === "function") {
      id = window.crypto.randomUUID();
    } else {
      id = `sess_${Math.random().toString(36).slice(2, 10)}${Date.now().toString(36)}`;
    }
    localStorage.setItem(key, id);
    return id;
  }

  const sessionId = getOrCreateSessionId();

  function ensureSessionId(rawUrl) {
    if (!rawUrl) return rawUrl;
    try {
      const url = new URL(rawUrl);
      if (!url.searchParams.get("session_id")) {
        url.searchParams.set("session_id", sessionId);
      }
      return url.toString();
    } catch {
      return rawUrl;
    }
  }

  if (wsUrlEl && wsUrlEl.value) {
    wsUrlEl.value = ensureSessionId(wsUrlEl.value);
  }

  const audioEl = new Audio();
  audioEl.autoplay = true;
  audioEl.playsInline = true;
  audioEl.setAttribute("playsinline", "");
  audioEl.preload = "auto";
  audioEl.muted = audioOutputMuted;
  audioEl.style.display = "none";
  document.body.appendChild(audioEl);
  audioEl.onplay = () => {
    if (audioUnlocking) return;
    if (!audioOutputMuted) setAiSpeaking(true);
  };
  audioEl.onpause = () => {
    if (audioUnlocking) return;
    setAiSpeaking(false);
  };
  audioEl.onended = () => {
    if (audioUnlocking) return;
    setAiSpeaking(false);
    if (audioEl.src) {
      if (audioEl.src.startsWith("blob:")) URL.revokeObjectURL(audioEl.src);
      audioEl.src = "";
    }
    pendingAudioBlob = null;
    if (pendingAudioUrl) {
      URL.revokeObjectURL(pendingAudioUrl);
      pendingAudioUrl = "";
    }
  };

  function log(...args) {
    if (!logEl) return;
    const s = args.join(" ");
    logEl.textContent += s + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(...args);
  }

  function setStatus(s) {
    if (!statusEl) return;
    statusEl.textContent = s;
    statusEl.dataset.state = s;
  }

  function setSpeaking(active) {
    if (soundIconEl) soundIconEl.classList.toggle("disabled", !active);
  }

  function setAiSpeaking(active) {
    aiSpeaking = active;
    if (active) aiProcessing = false;
    setSpeaking(active);
    if (!active && pendingAiText) {
      if (aiTextEl) aiTextEl.textContent = pendingAiText;
      pendingAiText = "";
    }
    if (speakingGuardId) {
      clearTimeout(speakingGuardId);
      speakingGuardId = null;
    }
    if (active) {
      // Guard against stuck "speaking" state on mobile autoplay failures.
      speakingGuardId = setTimeout(() => {
        if (!audioEl.paused) return;
        setAiSpeaking(false);
      }, 12000);
    }
    updateTalkState();
  }

  function setAiProcessing(active) {
    aiProcessing = active;
    if (active) aiSpeaking = false;
    if (!active && !aiSpeaking && pendingAiText) {
      if (aiTextEl) aiTextEl.textContent = pendingAiText;
      pendingAiText = "";
    }
    updateTalkState();
  }

  function showAudioUnlock(show) {
    if (!audioUnlockEl) return;
    audioUnlockEl.classList.toggle("hidden", !show);
  }

  function showCallScreen(active) {
    if (screenIdle) screenIdle.classList.toggle("hidden", active);
    if (screenCall) screenCall.classList.toggle("hidden", !active);
  }

  function resetPanels() {
    if (chatPanel) chatPanel.classList.remove("hidden");
    if (advancedPanel) advancedPanel.classList.remove("hidden");
    if (btnKeypad) btnKeypad.classList.remove("active");
    if (btnMore) btnMore.classList.remove("active");
  }

  function updateCallTimer() {
    if (!callTimerEl) return;
    if (!callStartMs) {
      callTimerEl.textContent = "00:00";
      return;
    }
    const total = Math.floor((Date.now() - callStartMs) / 1000);
    const minutes = String(Math.floor(total / 60)).padStart(2, "0");
    const seconds = String(total % 60).padStart(2, "0");
    callTimerEl.textContent = `${minutes}:${seconds}`;
  }

  function startCallTimer() {
    callStartMs = Date.now();
    updateCallTimer();
    clearInterval(callTimerId);
    callTimerId = setInterval(updateCallTimer, 1000);
  }

  function stopCallTimer() {
    clearInterval(callTimerId);
    callTimerId = null;
    callStartMs = 0;
    updateCallTimer();
  }

  function setControlState(isConnected) {
    const enabled = !!isConnected || callInitiated;
    [btnMute, btnKeypad, btnAudio, btnHold, btnRecord, btnMore, btnHangup]
      .filter(Boolean)
      .forEach((btn) => btn.disabled = !enabled);
    if (btnSend) btnSend.disabled = !enabled;
    if (btnRefreshVoices) btnRefreshVoices.disabled = !enabled;
  }

  function updateMuteButton() {
    if (!btnMute || !labelMute) return;
    const live = !!micRunning;
    if (pushToTalkEnabled) {
      labelMute.textContent = live ? "Talking" : "Hold to Talk";
      btnMute.classList.toggle("active", live);
      return;
    }
    labelMute.textContent = live ? "Mute" : "Unmute";
    btnMute.classList.toggle("active", live);
  }

  function updateAudioButton() {
    if (!btnAudio || !labelAudio) return;
    labelAudio.textContent = audioOutputMuted ? "Audio Off" : "Audio";
    btnAudio.classList.toggle("active", !audioOutputMuted);
  }

  function updateRecordButton() {
    if (labelRecord) labelRecord.textContent = recording ? "Stop" : "Record";
    if (btnRecord) btnRecord.classList.toggle("active", recording);
    if (recIndicatorEl) recIndicatorEl.classList.toggle("active", recording);
  }

  function updateKeypadButton() {
    if (!btnKeypad) return;
    const open = chatPanel && !chatPanel.classList.contains("hidden");
    btnKeypad.classList.toggle("active", open);
    if (labelKeypad) labelKeypad.textContent = open ? "Chat" : "Keypad";
  }

  function updateTalkState() {
    if (!talkStateDotEl || !talkStateLabelEl) return;
    let state = "muted";
    let label = "Muted";
    if (turnState === "speaking") {
      state = "speaking";
      label = "Speaking";
    } else if (turnState === "processing") {
      state = "processing";
      label = "Processing";
    } else if (turnState === "listening") {
      state = "listening";
      label = micRunning ? "Listening" : (autoListenEnabled ? "Ready" : "Muted");
    } else if (turnState === "idle") {
      state = "muted";
      label = "Idle";
    }
    talkStateDotEl.className = `state-dot ${state}`;
    talkStateLabelEl.textContent = label;
  }

  function applyTurnState(state) {
    turnState = state || "idle";
    if (turnState === "speaking") {
      aiSpeaking = true;
      aiProcessing = false;
    } else if (turnState === "processing") {
      aiProcessing = true;
      aiSpeaking = false;
    } else {
      aiProcessing = false;
      aiSpeaking = false;
    }

    if (turnState !== "speaking" && pendingAiText) {
      if (aiTextEl) aiTextEl.textContent = pendingAiText;
      pendingAiText = "";
    }

    if (turnState === "speaking" || turnState === "processing") {
      if (micRunning) stopMic();
    } else if (turnState === "listening") {
      if (!pushToTalkEnabled && autoListenEnabled && !micRunning) startMic();
    }

    updateTalkState();
  }

  function wsSendJson(obj) {
    if (ws && ws.readyState === 1) ws.send(JSON.stringify(obj));
  }

  function requestVoiceList() {
    if (!ws || ws.readyState !== 1) return;
    wsSendJson({ type: "get_voices" });
  }

  function setServerVoice(name) {
    const voice = (name || "").trim();
    if (!voice || !ws || ws.readyState !== 1) return;
    serverVoice = voice;
    wsSendJson({ type: "set_voice", voice });
  }

  function loadVoices() {
    if (!voiceSelect) return;
    voices = window.speechSynthesis?.getVoices?.() || [];
    voiceSelect.innerHTML = "";
    voices.forEach((v, idx) => {
      const opt = document.createElement("option");
      opt.value = String(idx);
      opt.textContent = `${v.name} (${v.lang})`;
      voiceSelect.appendChild(opt);
    });
    const enIndex = voices.findIndex(v => (v.lang || "").toLowerCase().startsWith("en"));
    if (enIndex >= 0) voiceSelect.value = String(enIndex);
  }

  function stopBrowserTTS() {
    if ("speechSynthesis" in window) window.speechSynthesis.cancel();
    setSpeaking(false);
  }

  function stopIncomingAudio() {
    if (!audioEl.paused) audioEl.pause();
    if (audioEl.src) {
      if (audioEl.src.startsWith("blob:")) URL.revokeObjectURL(audioEl.src);
      audioEl.src = "";
    }
    ttsChunks = [];
    setAiSpeaking(false);
    pendingAudioBlob = null;
    if (pendingAudioUrl) {
      URL.revokeObjectURL(pendingAudioUrl);
      pendingAudioUrl = "";
    }
  }

  function speakBrowserTTS(text) {
    if (audioOutputMuted) return;
    if (!("speechSynthesis" in window)) {
      log("[warn] speechSynthesis not supported (text only)");
      return;
    }
    stopBrowserTTS();
    const u = new SpeechSynthesisUtterance(text);
    const idx = parseInt(voiceSelect?.value || "0", 10);
    if (voices[idx]) u.voice = voices[idx];
    u.rate = parseFloat(rateEl?.value || "1.0");
    u.onstart = () => setAiSpeaking(true);
    u.onend = () => setAiSpeaking(false);
    u.onerror = () => setAiSpeaking(false);
    window.speechSynthesis.speak(u);
  }

  if ("speechSynthesis" in window) {
    window.speechSynthesis.onvoiceschanged = loadVoices;
    loadVoices();
  }
  if (rateEl && rateVal) {
    rateEl.addEventListener("input", () => rateVal.textContent = rateEl.value);
  }

  function ensureMixCtx() {
    if (!mixCtx) mixCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (mixCtx.state === "suspended") mixCtx.resume();
  }

  function ensureAiSource() {
    if (aiSource) return;
    ensureMixCtx();
    aiSource = mixCtx.createMediaElementSource(audioEl);
    aiSource.connect(mixCtx.destination);
    if (mixDest) aiSource.connect(mixDest);
  }

  function ensureMixDest() {
    ensureMixCtx();
    if (!mixDest) {
      mixDest = mixCtx.createMediaStreamDestination();
      if (aiSource) aiSource.connect(mixDest);
      if (sourceNode) sourceNode.connect(mixDest);
    }
  }

  function playPendingAudio() {
    if (!pendingAudioBlob) return;
    if (audioOutputMuted) return;
    if (pendingAudioUrl) URL.revokeObjectURL(pendingAudioUrl);
    pendingAudioUrl = URL.createObjectURL(pendingAudioBlob);
    audioEl.src = pendingAudioUrl;
    audioEl.play().then(() => {
      setAiSpeaking(true);
      showAudioUnlock(false);
    }).catch(() => {
      audioUnlocked = false;
      setAiSpeaking(false);
      showAudioUnlock(true);
    });
  }

  function unlockAudioPlayback() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    ensureMixCtx();
    // Play a tiny silent buffer to unlock the audio context on mobile.
    try {
      const buffer = mixCtx.createBuffer(1, 1, mixCtx.sampleRate);
      const source = mixCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(mixCtx.destination);
      source.start(0);
    } catch {}
    // Prime the media element with a silent clip.
    try {
      audioUnlocking = true;
      audioEl.muted = true;
      audioEl.src = SILENT_WAV;
      audioEl.play().catch(() => {});
      setTimeout(() => {
        audioEl.pause();
        audioEl.muted = audioOutputMuted;
        if (audioEl.src) {
          if (audioEl.src.startsWith("blob:")) URL.revokeObjectURL(audioEl.src);
          audioEl.src = "";
        }
        audioUnlocking = false;
      }, 120);
    } catch {}
    showAudioUnlock(false);
    setTimeout(playPendingAudio, 0);
    if (pendingConnect) {
      pendingConnect = false;
      connect();
    }
  }

  function addRecording(blob) {
    if (!recordingsEl) return;
    const url = URL.createObjectURL(blob);
    const stamp = new Date().toISOString().replace(/[:.]/g, "-");
    const link = document.createElement("a");
    link.href = url;
    link.download = `call-${stamp}.webm`;
    link.textContent = `Download recording ${stamp}`;
    recordingsEl.prepend(link);
  }

  function startRecording() {
    if (!("MediaRecorder" in window)) {
      log("[warn] MediaRecorder not supported");
      return;
    }
    ensureAiSource();
    ensureMixDest();
    recordChunks = [];
    let recorder;
    const mime = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
      ? "audio/webm;codecs=opus"
      : "audio/webm";
    try {
      recorder = new MediaRecorder(mixDest.stream, { mimeType: mime });
    } catch {
      recorder = new MediaRecorder(mixDest.stream);
    }
    recordRecorder = recorder;
    recorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) recordChunks.push(e.data);
    };
    recorder.onstop = () => {
      const blob = new Blob(recordChunks, { type: recorder.mimeType || "audio/webm" });
      addRecording(blob);
    };
    recorder.start();
    recording = true;
    updateRecordButton();
    log("[rec] started");
  }

  function stopRecording() {
    if (recordRecorder && recordRecorder.state !== "inactive") {
      recordRecorder.stop();
    }
    recording = false;
    updateRecordButton();
    log("[rec] stopped");
  }

  function setOutputMuted(muted) {
    audioOutputMuted = !!muted;
    audioEl.muted = audioOutputMuted;
    if (audioOutputMuted) {
      stopBrowserTTS();
      stopIncomingAudio();
    }
    updateAudioButton();
  }

  // Audio helpers
  function floatTo16BitPCM(float32Array) {
    const out = new Int16Array(float32Array.length);
    for (let i = 0; i < float32Array.length; i++) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return out;
  }

  function downsampleTo16k(float32Array, inRate) {
    if (inRate === 16000) return float32Array;
    const ratio = inRate / 16000;
    const newLen = Math.round(float32Array.length / ratio);
    const result = new Float32Array(newLen);
    let offset = 0;
    for (let i = 0; i < newLen; i++) {
      const nextOffset = Math.round((i + 1) * ratio);
      let sum = 0, count = 0;
      for (let j = offset; j < nextOffset && j < float32Array.length; j++) {
        sum += float32Array[j];
        count++;
      }
      result[i] = count ? sum / count : 0;
      offset = nextOffset;
    }
    return result;
  }

  function setCallState(state) {
    if (state === "idle") {
      connected = false;
      showCallScreen(false);
      if (layoutEl) layoutEl.classList.add("single");
      setStatus("DISCONNECTED");
      setControlState(false);
      stopCallTimer();
      resetPanels();
      updateMuteButton();
      updateAudioButton();
      updateRecordButton();
      autoListenEnabled = false;
      applyTurnState("idle");
      if (btnCall) btnCall.disabled = false;
      return;
    }
    if (state === "connecting") {
      showCallScreen(true);
      if (layoutEl) layoutEl.classList.remove("single");
      setStatus("CONNECTING");
      setControlState(false);
      stopCallTimer();
      applyTurnState("idle");
      if (btnCall) btnCall.disabled = true;
      return;
    }
    if (state === "connected") {
      showCallScreen(true);
      if (layoutEl) layoutEl.classList.remove("single");
      setStatus("CONNECTED");
      setControlState(true);
      startCallTimer();
      applyTurnState("listening");
      if (btnCall) btnCall.disabled = true;
    }
  }

  async function connect() {
    const url = ensureSessionId((wsUrlEl?.value || "").trim());
    callInitiated = true;
    autoListenEnabled = !pushToTalkEnabled;
    setCallState("connecting");
    if (!url) {
      log("[warn] WS URL is empty");
      return;
    }

    if (ws && ws.readyState === 1) ws.close();

    ws = new WebSocket(url);
    ws.binaryType = "arraybuffer";

    ws.onopen = () => {
      connected = true;
      setCallState("connected");
      log("[ws] connected:", url);
      requestVoiceList();
    };

    ws.onmessage = (ev) => {
      if (typeof ev.data !== "string") return;
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "ready") {
        serverTtsEnabled = !!msg.server_tts_enabled;
        serverVoice = msg.voice || serverVoice;
        log("[server] ready", JSON.stringify(msg));
      } else if (msg.type === "turn_state") {
        applyTurnState(msg.state);
        log("[turn]", msg.state);
      } else if (msg.type === "transcript") {
        if (transcriptEl) transcriptEl.textContent = msg.text || "";
        log("[stt]", msg.text ? msg.text : "(empty)");
      } else if (msg.type === "ai_text") {
        const text = msg.text || "";
        if (aiTextEl) aiTextEl.textContent = text;
        pendingAiText = text;
        log("[ai]", text.slice(0, 180));
        if (text && !serverTtsEnabled) {
          speakBrowserTTS(text);
        } else if (text && serverTtsEnabled) {
          audioStartSeen = false;
          audioChunkSeen = false;
          ttsFallbackText = text;
          if (ttsFallbackTimer) clearTimeout(ttsFallbackTimer);
          if (ttsChunkFallbackTimer) clearTimeout(ttsChunkFallbackTimer);
          ttsFallbackTimer = setTimeout(() => {
            if (!audioStartSeen) speakBrowserTTS(ttsFallbackText);
          }, 1500);
        }
      } else if (msg.type === "audio_start") {
        audioStartSeen = true;
        audioChunkSeen = false;
        if (ttsFallbackTimer) {
          clearTimeout(ttsFallbackTimer);
          ttsFallbackTimer = null;
        }
        if (ttsChunkFallbackTimer) clearTimeout(ttsChunkFallbackTimer);
        ttsChunkFallbackTimer = setTimeout(() => {
          if (!audioChunkSeen) speakBrowserTTS(ttsFallbackText);
        }, 1500);
        stopIncomingAudio();
        ttsChunks = [];
      } else if (msg.type === "audio_chunk") {
        if (!msg.data) return;
        audioChunkSeen = true;
        if (ttsChunkFallbackTimer) {
          clearTimeout(ttsChunkFallbackTimer);
          ttsChunkFallbackTimer = null;
        }
        const bin = atob(msg.data);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        ttsChunks.push(bytes);
      } else if (msg.type === "audio_end") {
        if (ttsChunkFallbackTimer) {
          clearTimeout(ttsChunkFallbackTimer);
          ttsChunkFallbackTimer = null;
        }
        if (!ttsChunks.length) {
          if (ttsFallbackText) speakBrowserTTS(ttsFallbackText);
          return;
        }
        if (audioOutputMuted) {
          ttsChunks = [];
          setAiSpeaking(false);
          return;
        }
        if (recording) ensureAiSource();
        pendingAudioBlob = new Blob(ttsChunks, { type: "audio/mpeg" });
        playPendingAudio();
        setTimeout(() => {
          if (!audioEl.paused) setAiSpeaking(true);
        }, 80);
        setAiProcessing(false);
      } else if (msg.type === "voices") {
        const list = Array.isArray(msg.voices) ? msg.voices : [];
        if (!serverVoiceSelect) return;
        serverVoiceSelect.innerHTML = "";
        list.forEach((v) => {
          const name = v.name || v.ShortName || "";
          if (!name) return;
          const opt = document.createElement("option");
          opt.value = name;
          const meta = [v.locale || v.Locale, v.gender || v.Gender].filter(Boolean).join(" â€¢ ");
          opt.textContent = meta ? `${name} (${meta})` : name;
          serverVoiceSelect.appendChild(opt);
        });
        if (serverVoice && Array.from(serverVoiceSelect.options).some(o => o.value === serverVoice)) {
          serverVoiceSelect.value = serverVoice;
        } else if (serverVoiceSelect.options.length) {
          serverVoiceSelect.selectedIndex = 0;
        }
      } else if (msg.type === "voice_set") {
        serverVoice = msg.voice || serverVoice;
        if (serverVoiceSelect && serverVoice) {
          const hasVoice = Array.from(serverVoiceSelect.options).some(o => o.value === serverVoice);
          if (hasVoice) serverVoiceSelect.value = serverVoice;
        }
      } else if (msg.type === "stop_audio") {
        stopBrowserTTS();
        stopIncomingAudio();
        setAiSpeaking(false);
        setAiProcessing(false);
        if (ttsFallbackTimer) {
          clearTimeout(ttsFallbackTimer);
          ttsFallbackTimer = null;
        }
        if (ttsChunkFallbackTimer) {
          clearTimeout(ttsChunkFallbackTimer);
          ttsChunkFallbackTimer = null;
        }
        log("[tts] stop_audio received");
      } else if (msg.type === "speech_start") {
        log("[vad] speech_start");
        const browserSpeaking = ("speechSynthesis" in window && window.speechSynthesis.speaking);
        const serverAudioPlaying = !audioEl.paused;
        if (allowBargeIn && (browserSpeaking || serverAudioPlaying)) {
          log("[vad] barge-in (AI was speaking)");
          stopBrowserTTS();
          stopIncomingAudio();
          wsSendJson({ type: "barge_in" });
        }
      } else if (msg.type === "speech_end") {
        log("[vad] speech_end", msg.reason || "");
      } else if (msg.type === "error") {
        log("[server error]", msg.message || "unknown");
      } else {
        log("[server]", msg.type);
      }
    };

    ws.onclose = () => {
      connected = false;
      log("[ws] disconnected");
      stopIncomingAudio();
      stopBrowserTTS();
      applyTurnState("idle");
      if (micRunning) stopMic();
      if (recording) stopRecording();
      if (callInitiated) {
        showCallScreen(true);
        if (layoutEl) layoutEl.classList.remove("single");
        setStatus("DISCONNECTED");
        setControlState(false);
        stopCallTimer();
      } else {
        setCallState("idle");
      }
    };

    ws.onerror = (e) => log("[ws] error", e);
  }

  function hangup() {
    callInitiated = false;
    autoListenEnabled = false;
    if (ws && ws.readyState === 1) {
      ws.close();
    } else {
      applyTurnState("idle");
      setCallState("idle");
    }
  }

  async function startMic() {
    if (!ws || ws.readyState !== 1) {
      log("[warn] connect WS first");
      return;
    }
    if (micRunning) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      log("[mic] blocked: getUserMedia not available. Mobile browsers require HTTPS.");
      return;
    }
    if (!window.isSecureContext) {
      log("[mic] blocked: insecure context. Use https:// to enable mic on mobile.");
      return;
    }
    ensureMixCtx();
    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      log("[mic] permission error:", err?.name || err);
      return;
    }
    sourceNode = mixCtx.createMediaStreamSource(micStream);
    processor = mixCtx.createScriptProcessor(4096, 1, 1);

    processor.onaudioprocess = (e) => {
      if (!ws || ws.readyState !== 1) return;
      if (blockMicWhileAiSpeaking && (aiSpeaking || aiProcessing)) return;
      const input = e.inputBuffer.getChannelData(0);
      const down = downsampleTo16k(input, mixCtx.sampleRate);
      const pcm16 = floatTo16BitPCM(down);
      ws.send(pcm16.buffer);
    };

    sourceNode.connect(processor);
    processor.connect(mixCtx.destination);
    if (mixDest) sourceNode.connect(mixDest);

    micRunning = true;
    updateMuteButton();
    updateTalkState();
    log("[mic] started. Speak into mic.");
  }

  function stopMic() {
    if (processor) processor.disconnect();
    if (sourceNode) sourceNode.disconnect();
    if (micStream) micStream.getTracks().forEach(t => t.stop());

    processor = null;
    sourceNode = null;
    micStream = null;

    micRunning = false;
    updateMuteButton();
    updateTalkState();
    log("[mic] stopped.");
  }

  function toggleMic() {
    if (micRunning) {
      autoListenEnabled = false;
      stopMic();
      updateTalkState();
    } else {
      autoListenEnabled = true;
      if (turnState === "listening") startMic();
      updateTalkState();
    }
  }

  function toggleChatPanel() {
    if (!chatPanel) return;
    chatPanel.classList.toggle("hidden");
    updateKeypadButton();
    if (!chatPanel.classList.contains("hidden") && textInputEl) {
      textInputEl.focus();
    }
  }

  function toggleAdvancedPanel() {
    if (!advancedPanel) return;
    advancedPanel.classList.toggle("hidden");
    if (btnMore) btnMore.classList.toggle("active", !advancedPanel.classList.contains("hidden"));
  }

  function sendTextUtterance() {
    const text = (textInputEl?.value || "").trim();
    if (!text) return;
    if (!ws || ws.readyState !== 1) {
      log("[warn] connect WS first");
      return;
    }
    wsSendJson({ type: "text_utterance", text });
    log("[text] sent:", text.slice(0, 180));
    textInputEl.value = "";
  }

  function handleCallClick(e) {
    if (e && e.preventDefault) e.preventDefault();
    if (REQUIRE_AUDIO_UNLOCK && !audioUnlocked) {
      pendingConnect = true;
      setCallState("connecting");
      showAudioUnlock(true);
      return;
    }
    autoListenEnabled = !pushToTalkEnabled;
    unlockAudioPlayback();
    connect();
  }

  function bindTap(el, handler) {
    if (!el) return;
    el.addEventListener("click", handler);
    el.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handler(e);
    }, { passive: false });
  }

  if (btnCall) {
    btnCall.addEventListener("click", handleCallClick);
    btnCall.addEventListener("touchstart", handleCallClick, { passive: false });
  }
  if (btnHangup) bindTap(btnHangup, hangup);
  function pushToTalkStart(e) {
    if (e && e.preventDefault) e.preventDefault();
    if (pushToTalkActive) return;
    pushToTalkActive = true;
    if (pushToTalkStopTimer) {
      clearTimeout(pushToTalkStopTimer);
      pushToTalkStopTimer = null;
    }
    autoListenEnabled = false;
    unlockAudioPlayback();
    if (ws && ws.readyState === 1) wsSendJson({ type: "ptt_start" });
    startMic();
  }

  function pushToTalkStop(e) {
    if (e && e.preventDefault) e.preventDefault();
    if (!pushToTalkActive) return;
    pushToTalkActive = false;
    if (ws && ws.readyState === 1) wsSendJson({ type: "ptt_end" });
    if (pushToTalkStopTimer) clearTimeout(pushToTalkStopTimer);
    pushToTalkStopTimer = setTimeout(() => {
      stopMic();
      pushToTalkStopTimer = null;
    }, PUSH_TO_TALK_RELEASE_MS);
  }

  if (btnMute) {
    btnMute.addEventListener("mousedown", pushToTalkStart);
    btnMute.addEventListener("touchstart", pushToTalkStart, { passive: false });
    btnMute.addEventListener("pointerdown", pushToTalkStart);
    btnMute.addEventListener("mouseup", pushToTalkStop);
    btnMute.addEventListener("mouseleave", pushToTalkStop);
    btnMute.addEventListener("touchend", pushToTalkStop, { passive: false });
    btnMute.addEventListener("touchcancel", pushToTalkStop, { passive: false });
    btnMute.addEventListener("pointerup", pushToTalkStop);
    btnMute.addEventListener("pointercancel", pushToTalkStop);
  }
  if (btnKeypad) bindTap(btnKeypad, toggleChatPanel);
  if (btnAudio) bindTap(btnAudio, () => setOutputMuted(!audioOutputMuted));
  if (btnHold) bindTap(btnHold, () => {
    stopBrowserTTS();
    stopIncomingAudio();
    wsSendJson({ type: "barge_in" });
    log("[barge-in] hold");
  });
  if (btnRecord) bindTap(btnRecord, () => {
    if (recording) stopRecording();
    else startRecording();
  });
  if (btnMore) bindTap(btnMore, toggleAdvancedPanel);
  if (audioUnlockEl) bindTap(audioUnlockEl, unlockAudioPlayback);
  if (btnRefreshVoices) btnRefreshVoices.onclick = requestVoiceList;
  if (serverVoiceSelect) serverVoiceSelect.onchange = () => setServerVoice(serverVoiceSelect.value);

  if (btnSend) btnSend.onclick = sendTextUtterance;
  if (textInputEl) {
    textInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendTextUtterance();
      }
    });
  }

  updateMuteButton();
  updateAudioButton();
  updateRecordButton();
  setCallState("idle");

  window.addEventListener("pageshow", () => {
    if (!ws || ws.readyState !== 1) {
      setCallState("idle");
    }
  });
})();
</script>
</body>
</html>
